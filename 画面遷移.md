@画面遷移.md

-------------------------------------
# 共通機能をまとめる


## Screen&Popup共通
- 前画面の状況を把握できる
- Key inputが存在する
  - 遷移するたびに更新する
- 外部への情報送受信を行う
  - 返答が来る、あるいはタイムアウト時間まできちんと待機する
- 並行処理を担うことがある

## Screen共通
- 別のScreenに遷移する
  - 遷移時に情報を受信/送信できる
- Popupを出せる
  - Popupにも情報を渡せる
  - Popupが閉じられるまで処理を待機する
  - 閉じたらKey inputを更新しなおす必要がある
- 遷移先のコントローラクラスがわかっている
- サイズ 1024x768

## Popup共通
- 親となるScreenが存在する
  - のち、親Screenに情報を返せる(GetStatus)
  - そのためPopupが閉じられた後もインスタンスは維持される
- 遷移はしない
- 基本的に、情報を残さない
- 自動で閉じられる(デフォ1.5秒)
- サイズ 

-------------------------------------
# 処理

## Screen遷移
これがよくわかってないんだよな～
mainがぜんぶ掌握するのは避けたい(全Screenコントローラクラスが馬鹿みたいに並ぶ)
だから**遷移先がわかってる**各コントローラが、ある程度共通の処理を別のクラスに任せれば、綺麗になりそう



## 情報の送受信
対象コントローラクラスに送受信用メソッドを作って実現
- 送信: 対象のインスタンス生成時に引数を与える
  あるいはSetData的なやつで後々データを送信するのもアリ？
  使わないと思うけど。
- 受信: GetEndStatus

## 前画面の情報の把握
**static** dictでScreenごとに記録する
ポップアップ系は情報を残さないのでdictには何も格納しない
```
selectOperation:{
  mode: lend / return
  port: int
}
authentication:{
  tag_id?: String
  user_name?: String
  user_authority: int
}
```

## 共通メソッド
Screenスーパークラス、Popupスーパークラスが共通でもつ性質はMutualスーパークラスに継承させればいけるのでは？
親クラスの親クラスもsuper.methodGrandparentで呼び出せる！
それよりもinterfaceがいいな？
メソッドをまとめるために生まれたものだし、overrideしないやつはdefaultメソッドにすればいい
多重継承を回避する一般的なアプローチでいきたい



-------------------------------------

# メモ

## interface
interface Aを実装したクラスBは、B.method()でA.method()を呼び出せる
クラスCもAを実装すれば、C.method()でA.method()を呼び出せる
各々で中身を変えなければならないメソッドはinterfaceで定義し、overrideさせればいい

